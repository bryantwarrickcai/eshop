# Bryant Warrick Cai, 2306256255 - E-Shop
Link to application: https://eshop-bryantwarrickcai.koyeb.app/

## Module 1
### Reflection 1
I used meaningful names for my methods in the `ProductController` class, such as `editProductPage`, `editProductPost`, and `deleteProductPage`. These names clearly convey the purpose of these methods. I also used a `Map` instead of a `List` so that it's easier to access each product in the database based on the product ID (UUID). The form is also safe from XSS Attacks. This can be proven by trying to enter `<img src="x" onerror="alert('XSS Attack!')">` into the product name. It will interpret this as literal text instead of executing it as HTML code. A bit of a mistake in the code is that the product data will not stay on permanently, and will disappear if you stop the program and then run it again. A solution to this is to store the list of products in a file, and then accessing that file for the list of products.

### Reflection 2
1. The number of unit tests that need to be written in a class depends on the complexity and the functionality of your program. Several good rules of thumb include testing every public method, covering all possible scenarios and edge cases, and writing one test per behavior and not per method. To ensure that the number of unit tests are enough for our program, we have to measure how much of the code coverage is executed by our tests, and for each function, we need to verify different possible scenarios that can happen (including those that lead to errors). We also have to perform boundary testing, which is testing the extreme and edge cases for our program. 100% code coverage does not ensure that our code is free of bugs or errors. This may be because of some test cases that we haven't though of yet (missing) (such as untested edge cases) and unanticipated scenarios. Code coverage only ensures execution, not correctness.
2. To verify the number of items in the product list, we can use similar code in `CreateProductFunctionalTest.java` for accessing the table, and getting a full list of `tr`'s using `findElements`. After this, we can find the number of elements in the list, and subtract 1 from this value (since the header row does not count as a product).<br><br>
I feel like this new code will not reduce the readability of the code overall. If necessary, comments can be added where it's not immediately clear what the code does (for example, when subtracting by 1, we can explain with a comment that it's to exclude the header row). We can also use more meaningful variable names to make it clear what the variable is about without requiring a comment to explain it. We should also use blank lines to make it clear that a group of the code is separate from another group, for easier code organization and make it look more visually pleasing.

## Module 2
### Reflection
1. I fixed two code quality issues that were detected by PMD. I removed all unused imports in the code, since it optimizes the code runtime and results in faster compilation times. In the `ProductService` interface, I removed the explicit `public` modifier, as all interface declarations in Java are implicitly `public`. I also changed the return values in `ProductController` so that its capitalization matches the capitalization of the file names, since file names aren't case-sensitive on Windows, but they are on Unix systems (which is what Koyeb uses).
2. I think that the current implementation has already met the definition of CI (continuous integration) and CD (continuous deployment). In my code, for CI, I use a shared repository (GitHub). I use a system to automatically run the unit tests whenever I do a push or pull request on GitHub. I also used OSSF Scorecard to check for any security vulnerabilities on my project. For CD, I use an automatic system to automatically deploy my code to Koyeb whenever I push my code to GitHub. Using this, I eliminate the need to manually deploy my code whenever I push to GitHub.

## Module 3
### Reflection
1. SRP: Yes. Every class in the whole project focuses on only one aspect of the code. For example, `CarController` focuses only on managing HTML requests related to displaying, managing, and deleting Car objects. The `Product` class contains everything related only for the product itself, which include a constructor for automatically generating the UUID as soon as that objcet is created, and an `edit` method to edit details of the product. The `CarServiceImpl` class focuses on things related to the service, re-implementing some methods from the car repository.<br>
<br>
OCP: Yes. OCP states that a class should be open for extension but closed for modification. In other words, we do not need to modify code of that class in order to add new functionalities; we can instead inherit from it. An example is the `Car` class. We do not need to modify the `Car` class to add new functionalities to it. Instead, we just need to modify `CarRepository` and `CarServiceImpl`.<br>
<br>
LSP: Yes. LSP states that when a subclass inherits from a base class, it should not change the behavior of the original base class. In this code, the only inheritance in our code is the `CarController` class inheriting from `ProductController`. We only created new methods from `ProductController`, not changing any of `ProductController`'s methods.<br>
<br>
ISP: No. I modified CarService.java so that I separate them into two services: CarServiceRead (methods for reading) and CarServiceWrite (methods for writing). I also did the same thing with ProductService.java, and I also changed the `service` in `ProductController` to use `ProductServiceImpl` instead of `ProductService`.<br>
<br>
DIP: No. This principle states that high-level modules should not depend on low-level modules, and should depend on abstractions instead. Additionally, abstraction should not depend on details, but rather the details must rely on abstraction. I fixed this code by adding interfaces for `CarRepository` and `ProductRepository` titled `CarRepositoryInterface` and `ProductRepositoryInterface` respectively.
2. Applying SOLID principles to a project can provide a significant amount of benefits that improve the maintainability of the project. One of the advantages include allowing it easier to modify, test, and extend a code. For example, by following the SRP principle, if there is a bug in a code, or if a part of a code needs to be changed, it is likely only contained within a specific class rather than scattered across the project, making it safer to debug and modify code without introducing more bugs. For example, if we need to modify some implementations regarding the HTML requests and other stuff, we can modify or add it directly in `CarController`.<br>
<br>
With the ISP principle, it ensures that clients are not forced to depend on interfaces that they do not use. By appling ISP, we can create separate interfaces for different functionality, to ensure that not all functionalities are forced. In this example, when I created two services for CarService (`CarServiceRead` and `CarServiceWrite`), we can ensure that a new service only implements the required functionalities and not all of them. If they need to implement all functionalities, they can use multiple interfaces in the class.<br>
<br>
Additionally, by implementing SOLID principles, it often leads to a more cleaner and intuitive design. This is especially beneficial when working in a team, as these principles follow guidelines that all team members can follow. The end result also leads to code that is easier for other people to understand and modify.
3. By not applying SOLID principles in our code, it can lead to many disadvantages. One of them is that different parts of the codebase may become too dependent on each other. This could make changing parts of the code risky, as it may break functionality of other parts of the system.<br>
<br>
Another disadvantage is reducing code reusability. By not following SOLID principles, it may be difficult to re-use part of a code in different parts of the application. For example, if a reporting system is designed only for one type of data format, it cannot be re-used for another format.<br>
<br>
Not following SOLID principles also makes your code harder to test. This makes unit testing difficult, as this type of code is often dependent on concrete implementations rather than abstractions. For example, if a service class directly creates database connections instead of depending on an interface, unit testing would require an actual database, making testing more difficult and slowing down development.
