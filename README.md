# Bryant Warrick Cai, 2306256255 - E-Shop
Link to application: https://eshop-bryantwarrickcai.koyeb.app/

## Module 1
### Reflection 1
I used meaningful names for my methods in the `ProductController` class, such as `editProductPage`, `editProductPost`, and `deleteProductPage`. These names clearly convey the purpose of these methods. I also used a `Map` instead of a `List` so that it's easier to access each product in the database based on the product ID (UUID). The form is also safe from XSS Attacks. This can be proven by trying to enter `<img src="x" onerror="alert('XSS Attack!')">` into the product name. It will interpret this as literal text instead of executing it as HTML code. A bit of a mistake in the code is that the product data will not stay on permanently, and will disappear if you stop the program and then run it again. A solution to this is to store the list of products in a file, and then accessing that file for the list of products.

### Reflection 2
1. The number of unit tests that need to be written in a class depends on the complexity and the functionality of your program. Several good rules of thumb include testing every public method, covering all possible scenarios and edge cases, and writing one test per behavior and not per method. To ensure that the number of unit tests are enough for our program, we have to measure how much of the code coverage is executed by our tests, and for each function, we need to verify different possible scenarios that can happen (including those that lead to errors). We also have to perform boundary testing, which is testing the extreme and edge cases for our program. 100% code coverage does not ensure that our code is free of bugs or errors. This may be because of some test cases that we haven't though of yet (missing) (such as untested edge cases) and unanticipated scenarios. Code coverage only ensures execution, not correctness.
2. To verify the number of items in the product list, we can use similar code in `CreateProductFunctionalTest.java` for accessing the table, and getting a full list of `tr`'s using `findElements`. After this, we can find the number of elements in the list, and subtract 1 from this value (since the header row does not count as a product).<br><br>
I feel like this new code will not reduce the readability of the code overall. If necessary, comments can be added where it's not immediately clear what the code does (for example, when subtracting by 1, we can explain with a comment that it's to exclude the header row). We can also use more meaningful variable names to make it clear what the variable is about without requiring a comment to explain it. We should also use blank lines to make it clear that a group of the code is separate from another group, for easier code organization and make it look more visually pleasing.

## Module 2
### Reflection
1. I fixed two code quality issues that were detected by PMD. I removed all unused imports in the code, since it optimizes the code runtime and results in faster compilation times. In the `ProductService` interface, I removed the explicit `public` modifier, as all interface declarations in Java are implicitly `public`. I also changed the return values in `ProductController` so that its capitalization matches the capitalization of the file names, since file names aren't case-sensitive on Windows, but they are on Unix systems (which is what Koyeb uses).
2. I think that the current implementation has already met the definition of CI (continuous integration) and CD (continuous deployment). In my code, for CI, I use a shared repository (GitHub). I use a system to automatically run the unit tests whenever I do a push or pull request on GitHub. I also used OSSF Scorecard to check for any security vulnerabilities on my project. For CD, I use an automatic system to automatically deploy my code to Koyeb whenever I push my code to GitHub. Using this, I eliminate the need to manually deploy my code whenever I push to GitHub.
